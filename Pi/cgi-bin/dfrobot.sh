#!/bin/bash
# CGI script called from an html form action. The stdout generated by this script is sent back to the browser,
# therefore it is important to capture all stdout output which must not be returned to the html.
# This can be done using '> /dev/null 2>&1' or writing to a logfile.

# Global variabele which will contain the message received from the socket.
# A global variabele is used as bash functions cannot return values.
globSocketMessageReceived=""
# Function to send a udp socket message to the server and receive the reply.
function socketSendAndReceive {
    # Open socket and redirect to filedescriptor #3
    exec 3<>/dev/udp/localhost/12345
    # Send message (first parameter) to socket.
    echo -n ${1} > /dev/null 2>&1 >&3
    # Read message back from socket into globSocketMessageReceived, with a timeout of 0.5 second.
    # This timeout is needed otherwise this script can hang!
    # The timeout must be smaller than the delay in the server loop.
    # With UDP sockets the below read command does not seem to work (times out), so we use dd instead.
    #read -r -t 0.5 globSocketMessageReceived <&3
    # The dd command below waits until a message is received. To create a timeout we use the 'timeout' function.
    # 'count' should be '1' to wait for one message.
    globSocketMessageReceived=$(timeout 0.5s dd count=1 <&3 2> /dev/null)
    if [ -z "$globSocketMessageReceived" ]
    then
        globSocketMessageReceived="no reply received!"
    fi
    # Close socket for read and write.
    exec 3<&-
    exec 3>&-
}

# Global variabele which will contain the status received.
# A global variabele is used as bash functions cannot return values.
globStatus=""
function handle_command {
    prompt=$(basename $0)
    # Reset the log file to zero length if the size gets too large.
    if [ $(stat -c %s /home/pi/log/dfrobot_log.txt) -gt 1000000 ]
    then
        echo -e "***** $(date), $prompt: START LOG  *****" > /home/pi/log/dfrobot_log.txt
    else
        echo -e "\n***** $(date), $prompt: START LOG  *****" >> /home/pi/log/dfrobot_log.txt
    fi

    if [ "${1}" == "start-stream-hq" ] || [ "${1}" == "start-stream-lq" ] || [ "${1}" == "stop-stream" ]
    then
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
        # Force complete page refresh to correctly show the new or stopped MJPEG stream.
        do_refresh_page=true
    elif [ "${1}" == "capture-start" ] || [ "${1}" == "capture-stop" ]
    then
        socketSendAndReceive "${1}"
    elif [ "${1}" == "forward" ] || [ "${1}" == "backward" ] || [ "${1}" == "left" ] || [ "${1}" == "right" ]
    then
        echo "***** $(date), $prompt: '${1} ${2}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1} ${2}"
    elif [ "${1}" == "cam-move" ]
    then
        echo "***** $(date), $prompt: '${1} ${2}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1} ${2}"
    elif [ "${1}" == "light-on" ] || [ "${1}" == "light-off" ]
    then
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
    elif [ "${1}" == "home-start" ]
    then
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
        # Force complete page refresh to correctly show the new MJPEG stream.
        do_refresh_page=true
    elif [ "${1}" == "home-stop" ]
    then
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
    elif [ "${1}" == "status" ]
    then
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
        globStatus=$globSocketMessageReceived
        # Indicate to refresh the status frame.
        do_refresh_frame=true
    else
        # All other commands given in the text box, just send it to the socket server.
        echo "***** $(date), $prompt: '${1}' command received" >> /home/pi/log/dfrobot_log.txt
        socketSendAndReceive "${1}"
    fi
}

# Refresh frame is default false. Only when a new status frame is needed, the value will be set to true.
do_refresh_frame=false
# Refresh page is default false. Only when a new MJPEG stream has to be loaded, the value will be set to true.
do_refresh_page=false

# CGI POST method handling code below taken from http://tuxx-home.at/cmt.php?article=/2005/06/17/T09_07_39/index.html
if [ "$REQUEST_METHOD" = "POST" ]
then
    read POST_STRING

    # replace all escaped percent signs with a single percent sign
    POST_STRING=$(echo $POST_STRING | sed 's/%%/%/g')

    # replace all ampersands with spaces for easier handling later
    POST_STRING=$(echo $POST_STRING | sed 's/&/ /g')

    # Now $POST_STRING contains 'cmd=<value>' where 'cmd' and '<value>' correspond with the
    # 'name' and 'value' attribute of the button pressed in the client side html file.
    # <value> contains a command and possibly a parameter, separated by a dot. For example 'cam-move.30'.
    # Filter out the command and parameter and store it in $COMMAND and $PARAMETER respectively.
    COMMAND_PLUS_PARAMETER="$(echo $POST_STRING | sed -n 's/^.*cmd=\([^ ]*\).*$/\1/p')"
    COMMAND="$(echo $COMMAND_PLUS_PARAMETER | sed -n 's/\([^.]*\).*$/\1/p')"
    PARAMETER="$(echo $COMMAND_PLUS_PARAMETER | sed -n 's/[^.]*\.\(.*$\)/\1/p')"
    # Call command handler.
    handle_command $COMMAND $PARAMETER
fi

# Now we must return a valid HTTP header to the client, otherwise an "Internal Server Error" will be generated.
# Below are three options:
# 1. Use HTTP header "Content-type" and then add an HTML meta 'refresh' to force a refresh of the page.
#    This has the disadvantage that the refresh is visible, dependent of the browser.
# 2. Use HTTP header "Location" and point it to the original page so this will also refresh the page.
#    This has the disadvantage that the refresh is visible, dependent of the browser.
# 3. Use the HTTP header "Status" and return code 304, which means "Not Modified".
#    This will prevent most browsers from reloading the page and is the preferred method.
#    The disadvantage that the new html content like the robot status is not updated.
# The best option might be to use option 3 when no status update is needed else option 2.

#echo -e "Location: ../index1.html\n"

if [ $do_refresh_page = true ]
then
    # If $do_refresh_page = true then the complete page has to be refreshed.
    # Reason for a complete page refresh is to correctly show a new MJPEG stream.
    # The page refresh is done by returning html which calls javascript function parent.location.reload().
    # First delay to make sure new the MJPEG stream is started.
    # This is especially needed in case the 'home-start' command is received
    # which will start a new MJPEG stream but takes a second to start.
    sleep 3
    echo -e "Content-type: text/html\n"
    echo -e "<html><head>\n"
    echo -e "<meta http-equiv=\"refresh\" content=\"5\">\n"
    echo -e "<script language=\"javascript\" type=\"text/javascript\">\n"
    echo -e "parent.location.reload();\n"
    echo -e "</script>\n"
    echo -e "</head></html>"
elif [ $do_refresh_frame = false ]
then
    echo -e "Status:304\n"
else
    # Send 'index1.html' to the web client, after replacing the 'feedbackstring' with the actual status.
    echo -e "Content-type: text/html\n"
    while read line
    do
        # Replace 'feedbackstring' in original string with the actual status.
        echo -e ${line/feedbackstring/$globStatus}
    done < ${1}
fi


